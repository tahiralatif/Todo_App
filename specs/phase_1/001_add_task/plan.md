# Implementation Plan: Add Task

**Feature:** 001_add_task
**Date:** 2026-01-01
**Spec:** add_task_spec.md

---

## Summary

Design and implement the Add Task feature for the Phase I CLI Todo application. This feature enables users to create new tasks with a title (required) and optional description. Tasks are stored in-memory with auto-incrementing IDs.

---

## Technical Context

**Language/Version:** Python 3.13+
**Primary Dependencies:** rich, questionary
**Storage:** In-memory (Python list/dict)
**Testing:** pytest (recommended)
**Target Platform:** CLI (terminal)
**Project Type:** Single CLI application
**Performance Goals:** Immediate response (<100ms per task creation)
**Constraints:** In-memory only, no persistence
**Scale/Scope:** Single user, small task list (<1000 tasks)

---

## Constitution Check

### Gates (Must Pass)

| Gate | Status | Notes |
|------|--------|-------|
| OOP Design | ✅ | Using Task class, TaskManager service, CLI controller |
| No Manual Coding | ✅ | All code generated by Claude Code |
| Spec-First Workflow | ✅ | Following spec strictly |
| Rich/Questionary | ✅ | Using libraries as specified |
| Single Responsibility | ✅ | Modular class design |

### Principles Verified

1. **Object-Oriented Design** - Task entity, TaskManager service, AddTaskCLI controller
2. **Modular Structure** - Separate modules for models, services, ui
3. **Senior-Level Code** - Type hints, docstrings, input validation, defensive programming

---

## Project Structure

### Source Code (repository root)

```
src/
├── models/
│   ├── __init__.py
│   └── task.py          # Task entity class
├── services/
│   ├── __init__.py
│   └── task_manager.py  # TaskService for CRUD operations
├── ui/
│   ├── __init__.py
│   └── cli_controller.py  # CLI interaction layer
└── main.py              # Application entry point

tests/
├── __init__.py
└── test_task_manager.py
```

### Feature Directory

```
specs/phase_1/001_add_task/
├── add_task_spec.md     # Feature specification
├── plan.md              # This file
└── tasks.md             # Implementation breakdown (via /sp.tasks)
```

---

## Architecture Decisions

### 1. Task ID Generation

**Decision:** Auto-incrementing integer using TaskManager's internal counter

**Rationale:**
- Simple and predictable for CLI users
- No need for UUID complexity in Phase I
- Sequential IDs are user-friendly for small task lists

**Alternative Considered:** UUID
- Rejected: Overkill for CLI, harder for users to type

### 2. In-Memory Storage

**Decision:** Python list in TaskManager singleton

**Rationale:**
- Meets "in-memory only" requirement
- Simple implementation for Phase I
- Fast O(1) append for task creation

**Alternative Considered:** Dictionary by ID
- Rejected: List is sufficient for sequential IDs

### 3. Validation Strategy

**Decision:** Input validation at CLI layer, entity validation at model layer

**Rationale:**
- User-friendly error messages via Rich
- Reusable validation logic in domain layer
- Separation of concerns

---

## Data Flow

```
User Input (Questionary)
         ↓
CLI Controller (add_task method)
         ↓
Validation (title not empty/whitespace)
         ↓
TaskManager.create_task()
         ↓
Task Entity (instantiation with ID, title, description, completed=False)
         ↓
TaskManager.task_store (in-memory list)
         ↓
Rich Success Panel (display confirmation)
```

---

## Class Design

### Task (models/task.py)

```python
class Task:
    """Represents a single todo task."""
    id: int
    title: str
    description: str | None
    completed: bool

    def __init__(self, id: int, title: str, description: str | None = None):
        """Create a new task (defaults to incomplete)."""
```

### TaskManager (services/task_manager.py)

```python
class TaskManager:
    """Manages in-memory task storage and operations."""
    _instance: TaskManager | None = None
    _next_id: int = 1
    _tasks: list[Task]

    @classmethod
    def get_instance(cls) -> TaskManager:
        """Singleton pattern for shared state."""

    def create_task(self, title: str, description: str | None = None) -> Task:
        """Create and store a new task. Returns the created Task."""

    def get_all_tasks(self) -> list[Task]:
        """Return all tasks."""

    def get_task_by_id(self, id: int) -> Task | None:
        """Retrieve task by ID."""
```

### AddTaskCLI (ui/cli_controller.py)

```python
class CLIController:
    """Handles CLI interactions using Rich and Questionary."""

    def add_task(self) -> None:
        """Interactive add task flow."""
```

---

## Error Scenarios

| Scenario | Handling |
|----------|----------|
| Empty title | Rich error panel + re-prompt |
| Whitespace-only title | Rich error panel + re-prompt |
| Task store unavailable | Raise TaskManagerError |

---

## Integration Points

- **Questionary:** `text.input()` for title and description
- **Rich:** `Panel`, `Text`, `console.print()` for feedback
- **TaskManager:** Dependency injection via singleton

---

## Complexity Tracking

> Not applicable - feature within constitutional bounds

---

## Next Steps

1. Generate `tasks.md` via `/sp.tasks` command
2. Implement Task model class
3. Implement TaskManager service
4. Implement CLI controller with Rich/Questionary
5. Create main.py entry point
6. Test with pytest

---

**Plan Generated:** 2026-01-01
**Feature:** Add Task (001_add_task)
**Status:** Ready for /sp.tasks
