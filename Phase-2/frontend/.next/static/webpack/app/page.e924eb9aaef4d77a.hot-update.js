"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   api: function() { return /* binding */ api; }\n/* harmony export */ });\n/**\r\n * API Client for Backend Integration\r\n * Base URL: http://localhost:8000\r\n */ const API_BASE_URL = \"http://localhost:8000\" || 0;\nclass ApiClient {\n    getHeaders() {\n        let includeAuth = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n        const headers = {\n            \"Content-Type\": \"application/json\"\n        };\n        if (includeAuth && \"object\" !== \"undefined\") {\n            const token = localStorage.getItem(\"token\");\n            if (token) {\n                headers[\"Authorization\"] = \"Bearer \".concat(token);\n            }\n        }\n        return headers;\n    }\n    async handleResponse(response) {\n        if (!response.ok) {\n            const error = await response.json().catch(()=>({\n                    detail: \"An error occurred\"\n                }));\n            throw new Error(error.detail || \"HTTP \".concat(response.status));\n        }\n        if (response.status === 204) {\n            return {};\n        }\n        return response.json();\n    }\n    // Auth APIs\n    async signup(name, email, password) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/auth/signup\"), {\n            method: \"POST\",\n            headers: this.getHeaders(false),\n            body: JSON.stringify({\n                name,\n                email,\n                password\n            })\n        });\n        return this.handleResponse(response);\n    }\n    async signin(email, password) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/auth/signin\"), {\n            method: \"POST\",\n            headers: this.getHeaders(false),\n            body: JSON.stringify({\n                email,\n                password\n            })\n        });\n        return this.handleResponse(response);\n    }\n    async logout() {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/auth/logout\"), {\n            method: \"POST\",\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    async getCurrentUser() {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/auth/me\"), {\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    // Task APIs\n    async getTasks(params) {\n        const queryParams = new URLSearchParams();\n        if (params === null || params === void 0 ? void 0 : params.status) queryParams.append(\"status\", params.status);\n        if (params === null || params === void 0 ? void 0 : params.priority) queryParams.append(\"priority\", params.priority);\n        if (params === null || params === void 0 ? void 0 : params.limit) queryParams.append(\"limit\", params.limit.toString());\n        if (params === null || params === void 0 ? void 0 : params.offset) queryParams.append(\"offset\", params.offset.toString());\n        if (params === null || params === void 0 ? void 0 : params.include_deleted) queryParams.append(\"include_deleted\", \"true\");\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/tasks?\").concat(queryParams.toString()), {\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    async getTask(taskId) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/tasks/\").concat(taskId), {\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    async createTask(title, description) {\n        let priority = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"MEDIUM\", due_date = arguments.length > 3 ? arguments[3] : void 0;\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/tasks\"), {\n            method: \"POST\",\n            headers: this.getHeaders(),\n            body: JSON.stringify({\n                title,\n                description,\n                priority,\n                due_date\n            })\n        });\n        return this.handleResponse(response);\n    }\n    async updateTask(taskId, data) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/tasks/\").concat(taskId), {\n            method: \"PATCH\",\n            headers: this.getHeaders(),\n            body: JSON.stringify(data)\n        });\n        return this.handleResponse(response);\n    }\n    async toggleTaskComplete(taskId) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/tasks/\").concat(taskId, \"/complete\"), {\n            method: \"PATCH\",\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    async deleteTask(taskId) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/tasks/\").concat(taskId), {\n            method: \"DELETE\",\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    async restoreTask(taskId) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/tasks/\").concat(taskId, \"/restore\"), {\n            method: \"POST\",\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    // Notification APIs\n    async getNotifications(params) {\n        const queryParams = new URLSearchParams();\n        if (params === null || params === void 0 ? void 0 : params.limit) queryParams.append(\"limit\", params.limit.toString());\n        if (params === null || params === void 0 ? void 0 : params.offset) queryParams.append(\"offset\", params.offset.toString());\n        if (params === null || params === void 0 ? void 0 : params.unread_only) queryParams.append(\"unread_only\", \"true\");\n        if (params === null || params === void 0 ? void 0 : params.sort) queryParams.append(\"sort\", params.sort);\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/notifications?\").concat(queryParams.toString()), {\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    async markNotificationRead(notificationId) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/notifications/\").concat(notificationId), {\n            method: \"PUT\",\n            headers: this.getHeaders(),\n            body: JSON.stringify({\n                is_read: true\n            })\n        });\n        return this.handleResponse(response);\n    }\n    async markAllNotificationsRead() {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/notifications/mark-all-read\"), {\n            method: \"PUT\",\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    async deleteNotification(notificationId) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/notifications/\").concat(notificationId), {\n            method: \"DELETE\",\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    async getUnreadCount() {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/notifications/unread/count\"), {\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    // Profile APIs\n    async getProfile() {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/profile\"), {\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    async updateProfile(data) {\n        // Remove empty strings and convert to null\n        const cleanedData = Object.fromEntries(Object.entries(data).map((param)=>{\n            let [key, value] = param;\n            return [\n                key,\n                value === \"\" ? null : value\n            ];\n        }));\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/profile\"), {\n            method: \"PUT\",\n            headers: this.getHeaders(),\n            body: JSON.stringify(cleanedData)\n        });\n        return this.handleResponse(response);\n    }\n    async uploadProfilePhoto(file) {\n        const formData = new FormData();\n        formData.append(\"file\", file);\n        const token =  true ? localStorage.getItem(\"token\") : 0;\n        const headers = {};\n        if (token) {\n            headers[\"Authorization\"] = \"Bearer \".concat(token);\n        }\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/profile/upload-photo\"), {\n            method: \"POST\",\n            headers,\n            body: formData\n        });\n        return this.handleResponse(response);\n    }\n    async deleteProfilePhoto() {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/profile/photo\"), {\n            method: \"DELETE\",\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    // Contact API\n    async submitContactForm(data) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/contact\"), {\n            method: \"POST\",\n            headers: this.getHeaders(false),\n            body: JSON.stringify(data)\n        });\n        return this.handleResponse(response);\n    }\n    constructor(baseURL){\n        this.baseURL = baseURL;\n    }\n}\nconst api = new ApiClient(API_BASE_URL);\n/* harmony default export */ __webpack_exports__[\"default\"] = (api);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBSTtRQUNsRixNQUFNSCxVQUF1QixDQUFDO1FBQzlCLElBQUlDLE9BQU87WUFDVEQsT0FBTyxDQUFDLGdCQUFnQixHQUFHLFVBQWdCLE9BQU5DO1FBQ3ZDO1FBRUEsTUFBTUksV0FBVyxNQUFNWSxNQUFNLEdBQWdCLE9BQWIsSUFBSSxDQUFDQyxPQUFPLEVBQUMsOEJBQTRCO1lBQ3ZFQyxRQUFRO1lBQ1JuQjtZQUNBb0IsTUFBTStDO1FBQ1I7UUFDQSxPQUFPLElBQUksQ0FBQy9ELGNBQWMsQ0FBQ0M7SUFDN0I7SUFFQSxNQUFNZ0UscUJBQXFCO1FBQ3pCLE1BQU1oRSxXQUFXLE1BQU1ZLE1BQU0sR0FBZ0IsT0FBYixJQUFJLENBQUNDLE9BQU8sRUFBQyx1QkFBcUI7WUFDaEVDLFFBQVE7WUFDUm5CLFNBQVMsSUFBSSxDQUFDRixVQUFVO1FBQzFCO1FBQ0EsT0FBTyxJQUFJLENBQUNNLGNBQWMsQ0FBQ0M7SUFDN0I7SUFFQSxjQUFjO0lBQ2QsTUFBTWlFLGtCQUFrQjNCLElBS3ZCLEVBQUU7UUFDRCxNQUFNdEMsV0FBVyxNQUFNWSxNQUFNLEdBQWdCLE9BQWIsSUFBSSxDQUFDQyxPQUFPLEVBQUMsaUJBQWU7WUFDMURDLFFBQVE7WUFDUm5CLFNBQVMsSUFBSSxDQUFDRixVQUFVLENBQUM7WUFDekJzQixNQUFNQyxLQUFLQyxTQUFTLENBQUNxQjtRQUN2QjtRQUNBLE9BQU8sSUFBSSxDQUFDdkMsY0FBYyxDQUFDQztJQUM3QjtJQXhRQWtFLFlBQVlyRCxPQUFlLENBQUU7UUFDM0IsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ2pCO0FBdVFGO0FBRU8sTUFBTXNELE1BQU0sSUFBSTNFLFVBQVVKLGNBQWM7QUFDL0MsK0RBQWUrRSxHQUFHQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvYXBpLnRzPzJmYWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEFQSSBDbGllbnQgZm9yIEJhY2tlbmQgSW50ZWdyYXRpb25cclxuICogQmFzZSBVUkw6IGh0dHA6Ly9sb2NhbGhvc3Q6ODAwMFxyXG4gKi9cclxuXHJcbmNvbnN0IEFQSV9CQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMCc7XHJcblxyXG5jbGFzcyBBcGlDbGllbnQge1xyXG4gIHByaXZhdGUgYmFzZVVSTDogc3RyaW5nO1xyXG5cclxuICBjb25zdHJ1Y3RvcihiYXNlVVJMOiBzdHJpbmcpIHtcclxuICAgIHRoaXMuYmFzZVVSTCA9IGJhc2VVUkw7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldEhlYWRlcnMoaW5jbHVkZUF1dGg6IGJvb2xlYW4gPSB0cnVlKTogSGVhZGVyc0luaXQge1xyXG4gICAgY29uc3QgaGVhZGVyczogSGVhZGVyc0luaXQgPSB7XHJcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChpbmNsdWRlQXV0aCAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpO1xyXG4gICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7dG9rZW59YDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBoZWFkZXJzO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVSZXNwb25zZTxUPihyZXNwb25zZTogUmVzcG9uc2UpOiBQcm9taXNlPFQ+IHtcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHsgZGV0YWlsOiAnQW4gZXJyb3Igb2NjdXJyZWQnIH0pKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLmRldGFpbCB8fCBgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c31gKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDQpIHtcclxuICAgICAgcmV0dXJuIHt9IGFzIFQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICB9XHJcblxyXG4gIC8vIEF1dGggQVBJc1xyXG4gIGFzeW5jIHNpZ251cChuYW1lOiBzdHJpbmcsIGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvYXV0aC9zaWdudXBgLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoZmFsc2UpLFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IG5hbWUsIGVtYWlsLCBwYXNzd29yZCB9KSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc2lnbmluKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvYXV0aC9zaWduaW5gLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoZmFsc2UpLFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVtYWlsLCBwYXNzd29yZCB9KSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgbG9nb3V0KCkge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVUkx9L2FwaS9hdXRoL2xvZ291dGAsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0SGVhZGVycygpLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRDdXJyZW50VXNlcigpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvYXV0aC9tZWAsIHtcclxuICAgICAgaGVhZGVyczogdGhpcy5nZXRIZWFkZXJzKCksXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcclxuICB9XHJcblxyXG4gIC8vIFRhc2sgQVBJc1xyXG4gIGFzeW5jIGdldFRhc2tzKHBhcmFtcz86IHtcclxuICAgIHN0YXR1cz86ICdhbGwnIHwgJ3BlbmRpbmcnIHwgJ2NvbXBsZXRlZCcgfCAnZGVsZXRlZCc7XHJcbiAgICBwcmlvcml0eT86ICdMT1cnIHwgJ01FRElVTScgfCAnSElHSCc7XHJcbiAgICBsaW1pdD86IG51bWJlcjtcclxuICAgIG9mZnNldD86IG51bWJlcjtcclxuICAgIGluY2x1ZGVfZGVsZXRlZD86IGJvb2xlYW47XHJcbiAgfSkge1xyXG4gICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XHJcbiAgICBpZiAocGFyYW1zPy5zdGF0dXMpIHF1ZXJ5UGFyYW1zLmFwcGVuZCgnc3RhdHVzJywgcGFyYW1zLnN0YXR1cyk7XHJcbiAgICBpZiAocGFyYW1zPy5wcmlvcml0eSkgcXVlcnlQYXJhbXMuYXBwZW5kKCdwcmlvcml0eScsIHBhcmFtcy5wcmlvcml0eSk7XHJcbiAgICBpZiAocGFyYW1zPy5saW1pdCkgcXVlcnlQYXJhbXMuYXBwZW5kKCdsaW1pdCcsIHBhcmFtcy5saW1pdC50b1N0cmluZygpKTtcclxuICAgIGlmIChwYXJhbXM/Lm9mZnNldCkgcXVlcnlQYXJhbXMuYXBwZW5kKCdvZmZzZXQnLCBwYXJhbXMub2Zmc2V0LnRvU3RyaW5nKCkpO1xyXG4gICAgaWYgKHBhcmFtcz8uaW5jbHVkZV9kZWxldGVkKSBxdWVyeVBhcmFtcy5hcHBlbmQoJ2luY2x1ZGVfZGVsZXRlZCcsICd0cnVlJyk7XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuICAgICAgYCR7dGhpcy5iYXNlVVJMfS9hcGkvdGFza3M/JHtxdWVyeVBhcmFtcy50b1N0cmluZygpfWAsXHJcbiAgICAgIHsgaGVhZGVyczogdGhpcy5nZXRIZWFkZXJzKCkgfVxyXG4gICAgKTtcclxuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFRhc2sodGFza0lkOiBudW1iZXIpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvdGFza3MvJHt0YXNrSWR9YCwge1xyXG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoKSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgY3JlYXRlVGFzayh0aXRsZTogc3RyaW5nLCBkZXNjcmlwdGlvbj86IHN0cmluZywgcHJpb3JpdHk6ICdMT1cnIHwgJ01FRElVTScgfCAnSElHSCcgPSAnTUVESVVNJywgZHVlX2RhdGU/OiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvdGFza3NgLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoKSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB0aXRsZSwgZGVzY3JpcHRpb24sIHByaW9yaXR5LCBkdWVfZGF0ZSB9KSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgdXBkYXRlVGFzayh0YXNrSWQ6IG51bWJlciwgZGF0YTogeyB0aXRsZT86IHN0cmluZzsgZGVzY3JpcHRpb24/OiBzdHJpbmc7IGNvbXBsZXRlZD86IGJvb2xlYW47IHByaW9yaXR5PzogJ0xPVycgfCAnTUVESVVNJyB8ICdISUdIJyB9KSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVSTH0vYXBpL3Rhc2tzLyR7dGFza0lkfWAsIHtcclxuICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxyXG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoKSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHRvZ2dsZVRhc2tDb21wbGV0ZSh0YXNrSWQ6IG51bWJlcikge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVUkx9L2FwaS90YXNrcy8ke3Rhc2tJZH0vY29tcGxldGVgLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BBVENIJyxcclxuICAgICAgaGVhZGVyczogdGhpcy5nZXRIZWFkZXJzKCksXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGRlbGV0ZVRhc2sodGFza0lkOiBudW1iZXIpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvdGFza3MvJHt0YXNrSWR9YCwge1xyXG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxyXG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoKSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcmVzdG9yZVRhc2sodGFza0lkOiBudW1iZXIpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvdGFza3MvJHt0YXNrSWR9L3Jlc3RvcmVgLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoKSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gIH1cclxuXHJcbiAgLy8gTm90aWZpY2F0aW9uIEFQSXNcclxuICBhc3luYyBnZXROb3RpZmljYXRpb25zKHBhcmFtcz86IHtcclxuICAgIGxpbWl0PzogbnVtYmVyO1xyXG4gICAgb2Zmc2V0PzogbnVtYmVyO1xyXG4gICAgdW5yZWFkX29ubHk/OiBib29sZWFuO1xyXG4gICAgc29ydD86ICdhc2MnIHwgJ2Rlc2MnO1xyXG4gIH0pIHtcclxuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xyXG4gICAgaWYgKHBhcmFtcz8ubGltaXQpIHF1ZXJ5UGFyYW1zLmFwcGVuZCgnbGltaXQnLCBwYXJhbXMubGltaXQudG9TdHJpbmcoKSk7XHJcbiAgICBpZiAocGFyYW1zPy5vZmZzZXQpIHF1ZXJ5UGFyYW1zLmFwcGVuZCgnb2Zmc2V0JywgcGFyYW1zLm9mZnNldC50b1N0cmluZygpKTtcclxuICAgIGlmIChwYXJhbXM/LnVucmVhZF9vbmx5KSBxdWVyeVBhcmFtcy5hcHBlbmQoJ3VucmVhZF9vbmx5JywgJ3RydWUnKTtcclxuICAgIGlmIChwYXJhbXM/LnNvcnQpIHF1ZXJ5UGFyYW1zLmFwcGVuZCgnc29ydCcsIHBhcmFtcy5zb3J0KTtcclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxyXG4gICAgICBgJHt0aGlzLmJhc2VVUkx9L2FwaS9ub3RpZmljYXRpb25zPyR7cXVlcnlQYXJhbXMudG9TdHJpbmcoKX1gLFxyXG4gICAgICB7IGhlYWRlcnM6IHRoaXMuZ2V0SGVhZGVycygpIH1cclxuICAgICk7XHJcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBtYXJrTm90aWZpY2F0aW9uUmVhZChub3RpZmljYXRpb25JZDogbnVtYmVyKSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVSTH0vYXBpL25vdGlmaWNhdGlvbnMvJHtub3RpZmljYXRpb25JZH1gLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BVVCcsXHJcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0SGVhZGVycygpLFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGlzX3JlYWQ6IHRydWUgfSksXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIG1hcmtBbGxOb3RpZmljYXRpb25zUmVhZCgpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvbm90aWZpY2F0aW9ucy9tYXJrLWFsbC1yZWFkYCwge1xyXG4gICAgICBtZXRob2Q6ICdQVVQnLFxyXG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoKSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZGVsZXRlTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbklkOiBudW1iZXIpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvbm90aWZpY2F0aW9ucy8ke25vdGlmaWNhdGlvbklkfWAsIHtcclxuICAgICAgbWV0aG9kOiAnREVMRVRFJyxcclxuICAgICAgaGVhZGVyczogdGhpcy5nZXRIZWFkZXJzKCksXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFVucmVhZENvdW50KCkge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVUkx9L2FwaS9ub3RpZmljYXRpb25zL3VucmVhZC9jb3VudGAsIHtcclxuICAgICAgaGVhZGVyczogdGhpcy5nZXRIZWFkZXJzKCksXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcclxuICB9XHJcblxyXG4gIC8vIFByb2ZpbGUgQVBJc1xyXG4gIGFzeW5jIGdldFByb2ZpbGUoKSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVSTH0vYXBpL3Byb2ZpbGVgLCB7XHJcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0SGVhZGVycygpLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyB1cGRhdGVQcm9maWxlKGRhdGE6IHtcclxuICAgIG5hbWU/OiBzdHJpbmc7XHJcbiAgICBmaXJzdF9uYW1lPzogc3RyaW5nO1xyXG4gICAgbGFzdF9uYW1lPzogc3RyaW5nO1xyXG4gICAgcGhvbmU/OiBzdHJpbmc7XHJcbiAgICBkYXRlX29mX2JpcnRoPzogc3RyaW5nO1xyXG4gICAgZ2VuZGVyPzogc3RyaW5nO1xyXG4gICAgYWRkcmVzcz86IHN0cmluZztcclxuICAgIGNpdHk/OiBzdHJpbmc7XHJcbiAgICBjb3VudHJ5Pzogc3RyaW5nO1xyXG4gICAgYmlvPzogc3RyaW5nO1xyXG4gIH0pIHtcclxuICAgIC8vIFJlbW92ZSBlbXB0eSBzdHJpbmdzIGFuZCBjb252ZXJ0IHRvIG51bGxcclxuICAgIGNvbnN0IGNsZWFuZWREYXRhID0gT2JqZWN0LmZyb21FbnRyaWVzKFxyXG4gICAgICBPYmplY3QuZW50cmllcyhkYXRhKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW1xyXG4gICAgICAgIGtleSxcclxuICAgICAgICB2YWx1ZSA9PT0gJycgPyBudWxsIDogdmFsdWVcclxuICAgICAgXSlcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVUkx9L2FwaS9wcm9maWxlYCwge1xyXG4gICAgICBtZXRob2Q6ICdQVVQnLFxyXG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoKSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoY2xlYW5lZERhdGEpLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyB1cGxvYWRQcm9maWxlUGhvdG8oZmlsZTogRmlsZSkge1xyXG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcclxuICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGZpbGUpO1xyXG5cclxuICAgIGNvbnN0IHRva2VuID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKSA6IG51bGw7XHJcbiAgICBjb25zdCBoZWFkZXJzOiBIZWFkZXJzSW5pdCA9IHt9O1xyXG4gICAgaWYgKHRva2VuKSB7XHJcbiAgICAgIGhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHt0b2tlbn1gO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvcHJvZmlsZS91cGxvYWQtcGhvdG9gLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzLFxyXG4gICAgICBib2R5OiBmb3JtRGF0YSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZGVsZXRlUHJvZmlsZVBob3RvKCkge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVUkx9L2FwaS9wcm9maWxlL3Bob3RvYCwge1xyXG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxyXG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoKSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29udGFjdCBBUElcclxuICBhc3luYyBzdWJtaXRDb250YWN0Rm9ybShkYXRhOiB7XHJcbiAgICBuYW1lOiBzdHJpbmc7XHJcbiAgICBlbWFpbDogc3RyaW5nO1xyXG4gICAgc3ViamVjdDogc3RyaW5nO1xyXG4gICAgbWVzc2FnZTogc3RyaW5nO1xyXG4gIH0pIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvY29udGFjdGAsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0SGVhZGVycyhmYWxzZSksXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgYXBpID0gbmV3IEFwaUNsaWVudChBUElfQkFTRV9VUkwpO1xyXG5leHBvcnQgZGVmYXVsdCBhcGk7XHJcbiJdLCJuYW1lcyI6WyJBUElfQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsIkFwaUNsaWVudCIsImdldEhlYWRlcnMiLCJpbmNsdWRlQXV0aCIsImhlYWRlcnMiLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJoYW5kbGVSZXNwb25zZSIsInJlc3BvbnNlIiwib2siLCJlcnJvciIsImpzb24iLCJjYXRjaCIsImRldGFpbCIsIkVycm9yIiwic3RhdHVzIiwic2lnbnVwIiwibmFtZSIsImVtYWlsIiwicGFzc3dvcmQiLCJmZXRjaCIsImJhc2VVUkwiLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInNpZ25pbiIsImxvZ291dCIsImdldEN1cnJlbnRVc2VyIiwiZ2V0VGFza3MiLCJwYXJhbXMiLCJxdWVyeVBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsImFwcGVuZCIsInByaW9yaXR5IiwibGltaXQiLCJ0b1N0cmluZyIsIm9mZnNldCIsImluY2x1ZGVfZGVsZXRlZCIsImdldFRhc2siLCJ0YXNrSWQiLCJjcmVhdGVUYXNrIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImR1ZV9kYXRlIiwidXBkYXRlVGFzayIsImRhdGEiLCJ0b2dnbGVUYXNrQ29tcGxldGUiLCJkZWxldGVUYXNrIiwicmVzdG9yZVRhc2siLCJnZXROb3RpZmljYXRpb25zIiwidW5yZWFkX29ubHkiLCJzb3J0IiwibWFya05vdGlmaWNhdGlvblJlYWQiLCJub3RpZmljYXRpb25JZCIsImlzX3JlYWQiLCJtYXJrQWxsTm90aWZpY2F0aW9uc1JlYWQiLCJkZWxldGVOb3RpZmljYXRpb24iLCJnZXRVbnJlYWRDb3VudCIsImdldFByb2ZpbGUiLCJ1cGRhdGVQcm9maWxlIiwiY2xlYW5lZERhdGEiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJtYXAiLCJrZXkiLCJ2YWx1ZSIsInVwbG9hZFByb2ZpbGVQaG90byIsImZpbGUiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiZGVsZXRlUHJvZmlsZVBob3RvIiwic3VibWl0Q29udGFjdEZvcm0iLCJjb25zdHJ1Y3RvciIsImFwaSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});