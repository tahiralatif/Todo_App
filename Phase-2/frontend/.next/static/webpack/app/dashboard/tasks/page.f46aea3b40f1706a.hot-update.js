"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/tasks/page",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   api: function() { return /* binding */ api; }\n/* harmony export */ });\n/**\r\n * API Client for Backend Integration\r\n * Base URL: http://localhost:8000\r\n */ const API_BASE_URL = \"http://localhost:8000\" || 0;\nclass ApiClient {\n    getHeaders() {\n        let includeAuth = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n        const headers = {\n            \"Content-Type\": \"application/json\"\n        };\n        if (includeAuth && \"object\" !== \"undefined\") {\n            const token = localStorage.getItem(\"token\");\n            if (token) {\n                headers[\"Authorization\"] = \"Bearer \".concat(token);\n            }\n        }\n        return headers;\n    }\n    async handleResponse(response) {\n        if (!response.ok) {\n            const error = await response.json().catch(()=>({\n                    detail: \"An error occurred\"\n                }));\n            throw new Error(error.detail || \"HTTP \".concat(response.status));\n        }\n        if (response.status === 204) {\n            return {};\n        }\n        return response.json();\n    }\n    // Auth APIs\n    async signup(name, email, password) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/auth/signup\"), {\n            method: \"POST\",\n            headers: this.getHeaders(false),\n            body: JSON.stringify({\n                name,\n                email,\n                password\n            })\n        });\n        return this.handleResponse(response);\n    }\n    async signin(email, password) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/auth/signin\"), {\n            method: \"POST\",\n            headers: this.getHeaders(false),\n            body: JSON.stringify({\n                email,\n                password\n            })\n        });\n        return this.handleResponse(response);\n    }\n    async logout() {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/auth/logout\"), {\n            method: \"POST\",\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    async getCurrentUser() {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/auth/me\"), {\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    // Task APIs\n    async getTasks(params) {\n        const queryParams = new URLSearchParams();\n        if (params === null || params === void 0 ? void 0 : params.status) queryParams.append(\"status\", params.status);\n        if (params === null || params === void 0 ? void 0 : params.priority) queryParams.append(\"priority\", params.priority);\n        if (params === null || params === void 0 ? void 0 : params.limit) queryParams.append(\"limit\", params.limit.toString());\n        if (params === null || params === void 0 ? void 0 : params.offset) queryParams.append(\"offset\", params.offset.toString());\n        if (params === null || params === void 0 ? void 0 : params.include_deleted) queryParams.append(\"include_deleted\", \"true\");\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/tasks?\").concat(queryParams.toString()), {\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    async getTask(taskId) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/tasks/\").concat(taskId), {\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    async createTask(title, description) {\n        let priority = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"MEDIUM\", due_date = arguments.length > 3 ? arguments[3] : void 0;\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/tasks\"), {\n            method: \"POST\",\n            headers: this.getHeaders(),\n            body: JSON.stringify({\n                title,\n                description,\n                priority,\n                due_date\n            })\n        });\n        return this.handleResponse(response);\n    }\n    async updateTask(taskId, data) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/tasks/\").concat(taskId), {\n            method: \"PATCH\",\n            headers: this.getHeaders(),\n            body: JSON.stringify(data)\n        });\n        return this.handleResponse(response);\n    }\n    async toggleTaskComplete(taskId) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/tasks/\").concat(taskId, \"/complete\"), {\n            method: \"PATCH\",\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    async deleteTask(taskId) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/tasks/\").concat(taskId), {\n            method: \"DELETE\",\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    async restoreTask(taskId) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/tasks/\").concat(taskId, \"/restore\"), {\n            method: \"POST\",\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    // Notification APIs\n    async getNotifications(params) {\n        const queryParams = new URLSearchParams();\n        if (params === null || params === void 0 ? void 0 : params.limit) queryParams.append(\"limit\", params.limit.toString());\n        if (params === null || params === void 0 ? void 0 : params.offset) queryParams.append(\"offset\", params.offset.toString());\n        if (params === null || params === void 0 ? void 0 : params.unread_only) queryParams.append(\"unread_only\", \"true\");\n        if (params === null || params === void 0 ? void 0 : params.sort) queryParams.append(\"sort\", params.sort);\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/notifications?\").concat(queryParams.toString()), {\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    async markNotificationRead(notificationId) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/notifications/\").concat(notificationId), {\n            method: \"PUT\",\n            headers: this.getHeaders(),\n            body: JSON.stringify({\n                is_read: true\n            })\n        });\n        return this.handleResponse(response);\n    }\n    async markAllNotificationsRead() {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/notifications/mark-all-read\"), {\n            method: \"PUT\",\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    async deleteNotification(notificationId) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/notifications/\").concat(notificationId), {\n            method: \"DELETE\",\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    async getUnreadCount() {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/notifications/unread/count\"), {\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    // Profile APIs\n    async getProfile() {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/profile\"), {\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    async updateProfile(data) {\n        // Remove empty strings and convert to null\n        const cleanedData = Object.fromEntries(Object.entries(data).map((param)=>{\n            let [key, value] = param;\n            return [\n                key,\n                value === \"\" ? null : value\n            ];\n        }));\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/profile\"), {\n            method: \"PUT\",\n            headers: this.getHeaders(),\n            body: JSON.stringify(cleanedData)\n        });\n        return this.handleResponse(response);\n    }\n    async uploadProfilePhoto(file) {\n        const formData = new FormData();\n        formData.append(\"file\", file);\n        const token =  true ? localStorage.getItem(\"token\") : 0;\n        const headers = {};\n        if (token) {\n            headers[\"Authorization\"] = \"Bearer \".concat(token);\n        }\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/profile/upload-photo\"), {\n            method: \"POST\",\n            headers,\n            body: formData\n        });\n        return this.handleResponse(response);\n    }\n    async deleteProfilePhoto() {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/profile/photo\"), {\n            method: \"DELETE\",\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    // Contact API\n    async submitContactForm(data) {\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/contact\"), {\n            method: \"POST\",\n            headers: this.getHeaders(false),\n            body: JSON.stringify(data)\n        });\n        return this.handleResponse(response);\n    }\n    constructor(baseURL){\n        this.baseURL = baseURL;\n    }\n}\nconst api = new ApiClient(API_BASE_URL);\n/* harmony default export */ __webpack_exports__[\"default\"] = (api);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXBpLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7O0NBR0MsR0FFRCxNQUFNQSxlQUFlQyx1QkFBK0IsSUFBSTtBQUV4RCxNQUFNRztJQU9JQyxhQUFxRDtZQUExQ0MsY0FBQUEsaUVBQXVCO1FBQ3hDLE1BQU1DLFVBQXVCO1lBQzNCLGdCQUFnQjtRQUNsQjtRQUVBLElBQUlELGVBQWUsYUFBa0IsYUFBYTtZQUNoRCxNQUFNRSxRQUFRQyxhQUFhQyxPQUFPLENBQUM7WUFDbkMsSUFBSUYsT0FBTztnQkFDVEQsT0FBTyxDQUFDLGdCQUFnQixHQUFHLFVBQWdCLE9BQU5DO1lBQ3ZDO1FBQ0Y7UUFFQSxPQUFPRDtJQUNUO0lBRUEsTUFBY0ksZUFBa0JDLFFBQWtCLEVBQWM7UUFDOUQsSUFBSSxDQUFDQSxTQUFTQyxFQUFFLEVBQUU7WUFDaEIsTUFBTUMsUUFBUSxNQUFNRixTQUFTRyxJQUFJLEdBQUdDLEtBQUssQ0FBQyxJQUFPO29CQUFFQyxRQUFRO2dCQUFvQjtZQUMvRSxNQUFNLElBQUlDLE1BQU1KLE1BQU1HLE1BQU0sSUFBSSxRQUF3QixPQUFoQkwsU0FBU08sTUFBTTtRQUN6RDtRQUVBLElBQUlQLFNBQVNPLE1BQU0sS0FBSyxLQUFLO1lBQzNCLE9BQU8sQ0FBQztRQUNWO1FBRUEsT0FBT1AsU0FBU0csSUFBSTtJQUN0QjtJQUVBLFlBQVk7SUFDWixNQUFNSyxPQUFPQyxJQUFZLEVBQUVDLEtBQWEsRUFBRUMsUUFBZ0IsRUFBRTtRQUMxRCxNQUFNWCxXQUFXLE1BQU1ZLE1BQU0sR0FBZ0IsT0FBYixJQUFJLENBQUNDLE9BQU8sRUFBQyxxQkFBbUI7WUFDOURDLFFBQVE7WUFDUm5CLFNBQVMsSUFBSSxDQUFDRixVQUFVLENBQUM7WUFDekJzQixNQUFNQyxLQUFLQyxTQUFTLENBQUM7Z0JBQUVSO2dCQUFNQztnQkFBT0M7WUFBUztRQUMvQztRQUNBLE9BQU8sSUFBSSxDQUFDWixjQUFjLENBQUNDO0lBQzdCO0lBRUEsTUFBTWtCLE9BQU9SLEtBQWEsRUFBRUMsUUFBZ0IsRUFBRTtRQUM1QyxNQUFNWCxXQUFXLE1BQU1ZLE1BQU0sR0FBZ0IsT0FBYixJQUFJLENBQUNDLE9BQU8sRUFBQyxxQkFBbUI7WUFDOURDLFFBQVE7WUFDUm5CLFNBQVMsSUFBSSxDQUFDRixVQUFVLENBQUM7WUFDekJzQixNQUFNQyxLQUFLQyxTQUFTLENBQUM7Z0JBQUVQO2dCQUFPQztZQUFTO1FBQ3pDO1FBQ0EsT0FBTyxJQUFJLENBQUNaLGNBQWMsQ0FBQ0M7SUFDN0I7SUFFQSxNQUFNbUIsU0FBUztRQUNiLE1BQU1uQixXQUFXLE1BQU1ZLE1BQU0sR0FBZ0IsT0FBYixJQUFJLENBQUNDLE9BQU8sRUFBQyxxQkFBbUI7WUFDOURDLFFBQVE7WUFDUm5CLFNBQVMsSUFBSSxDQUFDRixVQUFVO1FBQzFCO1FBQ0EsT0FBTyxJQUFJLENBQUNNLGNBQWMsQ0FBQ0M7SUFDN0I7SUFFQSxNQUFNb0IsaUJBQWlCO1FBQ3JCLE1BQU1wQixXQUFXLE1BQU1ZLE1BQU0sR0FBZ0IsT0FBYixJQUFJLENBQUNDLE9BQU8sRUFBQyxpQkFBZTtZQUMxRGxCLFNBQVMsSUFBSSxDQUFDRixVQUFVO1FBQzFCO1FBQ0EsT0FBTyxJQUFJLENBQUNNLGNBQWMsQ0FBQ0M7SUFDN0I7SUFFQSxZQUFZO0lBQ1osTUFBTXFCLFNBQVNDLE1BTWQsRUFBRTtRQUNELE1BQU1DLGNBQWMsSUFBSUM7UUFDeEIsSUFBSUYsbUJBQUFBLDZCQUFBQSxPQUFRZixNQUFNLEVBQUVnQixZQUFZRSxNQUFNLENBQUMsVUFBVUgsT0FBT2YsTUFBTTtRQUM5RCxJQUFJZSxtQkFBQUEsNkJBQUFBLE9BQVFJLFFBQVEsRUFBRUgsWUFBWUUsTUFBTSxDQUFDLFlBQVlILE9BQU9JLFFBQVE7UUFDcEUsSUFBSUosbUJBQUFBLDZCQUFBQSxPQUFRSyxLQUFLLEVBQUVKLFlBQVlFLE1BQU0sQ0FBQyxTQUFTSCxPQUFPSyxLQUFLLENBQUNDLFFBQVE7UUFDcEUsSUFBSU4sbUJBQUFBLDZCQUFBQSxPQUFRTyxNQUFNLEVBQUVOLFlBQVlFLE1BQU0sQ0FBQyxVQUFVSCxPQUFPTyxNQUFNLENBQUNELFFBQVE7UUFDdkUsSUFBSU4sbUJBQUFBLDZCQUFBQSxPQUFRUSxlQUFlLEVBQUVQLFlBQVlFLE1BQU0sQ0FBQyxtQkFBbUI7UUFFbkUsTUFBTXpCLFdBQVcsTUFBTVksTUFDckIsR0FBNkJXLE9BQTFCLElBQUksQ0FBQ1YsT0FBTyxFQUFDLGVBQW9DLE9BQXZCVSxZQUFZSyxRQUFRLEtBQ2pEO1lBQUVqQyxTQUFTLElBQUksQ0FBQ0YsVUFBVTtRQUFHO1FBRS9CLE9BQU8sSUFBSSxDQUFDTSxjQUFjLENBQUNDO0lBQzdCO0lBRUEsTUFBTStCLFFBQVFDLE1BQWMsRUFBRTtRQUM1QixNQUFNaEMsV0FBVyxNQUFNWSxNQUFNLEdBQTZCb0IsT0FBMUIsSUFBSSxDQUFDbkIsT0FBTyxFQUFDLGVBQW9CLE9BQVBtQixTQUFVO1lBQ2xFckMsU0FBUyxJQUFJLENBQUNGLFVBQVU7UUFDMUI7UUFDQSxPQUFPLElBQUksQ0FBQ00sY0FBYyxDQUFDQztJQUM3QjtJQUVBLE1BQU1pQyxXQUFXQyxLQUFhLEVBQUVDLFdBQW9CLEVBQXFFO1lBQW5FVCxXQUFBQSxpRUFBc0MsVUFBVVU7UUFDcEcsTUFBTXBDLFdBQVcsTUFBTVksTUFBTSxHQUFnQixPQUFiLElBQUksQ0FBQ0MsT0FBTyxFQUFDLGVBQWE7WUFDeERDLFFBQVE7WUFDUm5CLFNBQVMsSUFBSSxDQUFDRixVQUFVO1lBQ3hCc0IsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO2dCQUFFaUI7Z0JBQU9DO2dCQUFhVDtnQkFBVVU7WUFBUztRQUNoRTtRQUNBLE9BQU8sSUFBSSxDQUFDckMsY0FBYyxDQUFDQztJQUM3QjtJQUVBLE1BQU1xQyxXQUFXTCxNQUFjLEVBQUVNLElBQTRILEVBQUU7UUFDN0osTUFBTXRDLFdBQVcsTUFBTVksTUFBTSxHQUE2Qm9CLE9BQTFCLElBQUksQ0FBQ25CLE9BQU8sRUFBQyxlQUFvQixPQUFQbUIsU0FBVTtZQUNsRWxCLFFBQVE7WUFDUm5CLFNBQVMsSUFBSSxDQUFDRixVQUFVO1lBQ3hCc0IsTUFBTUMsS0FBS0MsU0FBUyxDQUFDcUI7UUFDdkI7UUFDQSxPQUFPLElBQUksQ0FBQ3ZDLGNBQWMsQ0FBQ0M7SUFDN0I7SUFFQSxNQUFNdUMsbUJBQW1CUCxNQUFjLEVBQUU7UUFDdkMsTUFBTWhDLFdBQVcsTUFBTVksTUFBTSxHQUE2Qm9CLE9BQTFCLElBQUksQ0FBQ25CLE9BQU8sRUFBQyxlQUFvQixPQUFQbUIsUUFBTyxjQUFZO1lBQzNFbEIsUUFBUTtZQUNSbkIsU0FBUyxJQUFJLENBQUNGLFVBQVU7UUFDMUI7UUFDQSxPQUFPLElBQUksQ0FBQ00sY0FBYyxDQUFDQztJQUM3QjtJQUVBLE1BQU13QyxXQUFXUixNQUFjLEVBQUU7UUFDL0IsTUFBTWhDLFdBQVcsTUFBTVksTUFBTSxHQUE2Qm9CLE9BQTFCLElBQUksQ0FBQ25CLE9BQU8sRUFBQyxlQUFvQixPQUFQbUIsU0FBVTtZQUNsRWxCLFFBQVE7WUFDUm5CLFNBQVMsSUFBSSxDQUFDRixVQUFVO1FBQzFCO1FBQ0EsT0FBTyxJQUFJLENBQUNNLGNBQWMsQ0FBQ0M7SUFDN0I7SUFFQSxNQUFNeUMsWUFBWVQsTUFBYyxFQUFFO1FBQ2hDLE1BQU1oQyxXQUFXLE1BQU1ZLE1BQU0sR0FBNkJvQixPQUExQixJQUFJLENBQUNuQixPQUFPLEVBQUMsZUFBb0IsT0FBUG1CLFFBQU8sYUFBVztZQUMxRWxCLFFBQVE7WUFDUm5CLFNBQVMsSUFBSSxDQUFDRixVQUFVO1FBQzFCO1FBQ0EsT0FBTyxJQUFJLENBQUNNLGNBQWMsQ0FBQ0M7SUFDN0I7SUFFQSxvQkFBb0I7SUFDcEIsTUFBTTBDLGlCQUFpQnBCLE1BS3RCLEVBQUU7UUFDRCxNQUFNQyxjQUFjLElBQUlDO1FBQ3hCLElBQUlGLG1CQUFBQSw2QkFBQUEsT0FBUUssS0FBSyxFQUFFSixZQUFZRSxNQUFNLENBQUMsU0FBU0gsT0FBT0ssS0FBSyxDQUFDQyxRQUFRO1FBQ3BFLElBQUlOLG1CQUFBQSw2QkFBQUEsT0FBUU8sTUFBTSxFQUFFTixZQUFZRSxNQUFNLENBQUMsVUFBVUgsT0FBT08sTUFBTSxDQUFDRCxRQUFRO1FBQ3ZFLElBQUlOLG1CQUFBQSw2QkFBQUEsT0FBUXFCLFdBQVcsRUFBRXBCLFlBQVlFLE1BQU0sQ0FBQyxlQUFlO1FBQzNELElBQUlILG1CQUFBQSw2QkFBQUEsT0FBUXNCLElBQUksRUFBRXJCLFlBQVlFLE1BQU0sQ0FBQyxRQUFRSCxPQUFPc0IsSUFBSTtRQUV4RCxNQUFNNUMsV0FBVyxNQUFNWSxNQUNyQixHQUFxQ1csT0FBbEMsSUFBSSxDQUFDVixPQUFPLEVBQUMsdUJBQTRDLE9BQXZCVSxZQUFZSyxRQUFRLEtBQ3pEO1lBQUVqQyxTQUFTLElBQUksQ0FBQ0YsVUFBVTtRQUFHO1FBRS9CLE9BQU8sSUFBSSxDQUFDTSxjQUFjLENBQUNDO0lBQzdCO0lBRUEsTUFBTTZDLHFCQUFxQkMsY0FBc0IsRUFBRTtRQUNqRCxNQUFNOUMsV0FBVyxNQUFNWSxNQUFNLEdBQXFDa0MsT0FBbEMsSUFBSSxDQUFDakMsT0FBTyxFQUFDLHVCQUFvQyxPQUFmaUMsaUJBQWtCO1lBQ2xGaEMsUUFBUTtZQUNSbkIsU0FBUyxJQUFJLENBQUNGLFVBQVU7WUFDeEJzQixNQUFNQyxLQUFLQyxTQUFTLENBQUM7Z0JBQUU4QixTQUFTO1lBQUs7UUFDdkM7UUFDQSxPQUFPLElBQUksQ0FBQ2hELGNBQWMsQ0FBQ0M7SUFDN0I7SUFFQSxNQUFNZ0QsMkJBQTJCO1FBQy9CLE1BQU1oRCxXQUFXLE1BQU1ZLE1BQU0sR0FBZ0IsT0FBYixJQUFJLENBQUNDLE9BQU8sRUFBQyxxQ0FBbUM7WUFDOUVDLFFBQVE7WUFDUm5CLFNBQVMsSUFBSSxDQUFDRixVQUFVO1FBQzFCO1FBQ0EsT0FBTyxJQUFJLENBQUNNLGNBQWMsQ0FBQ0M7SUFDN0I7SUFFQSxNQUFNaUQsbUJBQW1CSCxjQUFzQixFQUFFO1FBQy9DLE1BQU05QyxXQUFXLE1BQU1ZLE1BQU0sR0FBcUNrQyxPQUFsQyxJQUFJLENBQUNqQyxPQUFPLEVBQUMsdUJBQW9DLE9BQWZpQyxpQkFBa0I7WUFDbEZoQyxRQUFRO1lBQ1JuQixTQUFTLElBQUksQ0FBQ0YsVUFBVTtRQUMxQjtRQUNBLE9BQU8sSUFBSSxDQUFDTSxjQUFjLENBQUNDO0lBQzdCO0lBRUEsTUFBTWtELGlCQUFpQjtRQUNyQixNQUFNbEQsV0FBVyxNQUFNWSxNQUFNLEdBQWdCLE9BQWIsSUFBSSxDQUFDQyxPQUFPLEVBQUMsb0NBQWtDO1lBQzdFbEIsU0FBUyxJQUFJLENBQUNGLFVBQVU7UUFDMUI7UUFDQSxPQUFPLElBQUksQ0FBQ00sY0FBYyxDQUFDQztJQUM3QjtJQUVBLGVBQWU7SUFDZixNQUFNbUQsYUFBYTtRQUNqQixNQUFNbkQsV0FBVyxNQUFNWSxNQUFNLEdBQWdCLE9BQWIsSUFBSSxDQUFDQyxPQUFPLEVBQUMsaUJBQWU7WUFDMURsQixTQUFTLElBQUksQ0FBQ0YsVUFBVTtRQUMxQjtRQUNBLE9BQU8sSUFBSSxDQUFDTSxjQUFjLENBQUNDO0lBQzdCO0lBRUEsTUFBTW9ELGNBQWNkLElBV25CLEVBQUU7UUFDRCwyQ0FBMkM7UUFDM0MsTUFBTWUsY0FBY0MsT0FBT0MsV0FBVyxDQUNwQ0QsT0FBT0UsT0FBTyxDQUFDbEIsTUFBTW1CLEdBQUcsQ0FBQztnQkFBQyxDQUFDQyxLQUFLQyxNQUFNO21CQUFLO2dCQUN6Q0Q7Z0JBQ0FDLFVBQVUsS0FBSyxPQUFPQTthQUN2Qjs7UUFHSCxNQUFNM0QsV0FBVyxNQUFNWSxNQUFNLEdBQWdCLE9BQWIsSUFBSSxDQUFDQyxPQUFPLEVBQUMsaUJBQWU7WUFDMURDLFFBQVE7WUFDUm5CLFNBQVMsSUFBSSxDQUFDRixVQUFVO1lBQ3hCc0IsTUFBTUMsS0FBS0MsU0FBUyxDQUFDb0M7UUFDdkI7UUFDQSxPQUFPLElBQUksQ0FBQ3RELGNBQWMsQ0FBQ0M7SUFDN0I7SUFFQSxNQUFNNEQsbUJBQW1CQyxJQUFVLEVBQUU7UUFDbkMsTUFBTUMsV0FBVyxJQUFJQztRQUNyQkQsU0FBU3JDLE1BQU0sQ0FBQyxRQUFRb0M7UUFFeEIsTUFBTWpFLFFBQVEsS0FBa0IsR0FBY0MsYUFBYUMsT0FBTyxDQUFDLFdBQVcsQ0FBSTtRQUNsRixNQUFNSCxVQUF1QixDQUFDO1FBQzlCLElBQUlDLE9BQU87WUFDVEQsT0FBTyxDQUFDLGdCQUFnQixHQUFHLFVBQWdCLE9BQU5DO1FBQ3ZDO1FBRUEsTUFBTUksV0FBVyxNQUFNWSxNQUFNLEdBQWdCLE9BQWIsSUFBSSxDQUFDQyxPQUFPLEVBQUMsOEJBQTRCO1lBQ3ZFQyxRQUFRO1lBQ1JuQjtZQUNBb0IsTUFBTStDO1FBQ1I7UUFDQSxPQUFPLElBQUksQ0FBQy9ELGNBQWMsQ0FBQ0M7SUFDN0I7SUFFQSxNQUFNZ0UscUJBQXFCO1FBQ3pCLE1BQU1oRSxXQUFXLE1BQU1ZLE1BQU0sR0FBZ0IsT0FBYixJQUFJLENBQUNDLE9BQU8sRUFBQyx1QkFBcUI7WUFDaEVDLFFBQVE7WUFDUm5CLFNBQVMsSUFBSSxDQUFDRixVQUFVO1FBQzFCO1FBQ0EsT0FBTyxJQUFJLENBQUNNLGNBQWMsQ0FBQ0M7SUFDN0I7SUFFQSxjQUFjO0lBQ2QsTUFBTWlFLGtCQUFrQjNCLElBS3ZCLEVBQUU7UUFDRCxNQUFNdEMsV0FBVyxNQUFNWSxNQUFNLEdBQWdCLE9BQWIsSUFBSSxDQUFDQyxPQUFPLEVBQUMsaUJBQWU7WUFDMURDLFFBQVE7WUFDUm5CLFNBQVMsSUFBSSxDQUFDRixVQUFVLENBQUM7WUFDekJzQixNQUFNQyxLQUFLQyxTQUFTLENBQUNxQjtRQUN2QjtRQUNBLE9BQU8sSUFBSSxDQUFDdkMsY0FBYyxDQUFDQztJQUM3QjtJQXhRQWtFLFlBQVlyRCxPQUFlLENBQUU7UUFDM0IsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ2pCO0FBdVFGO0FBRU8sTUFBTXNELE1BQU0sSUFBSTNFLFVBQVVKLGNBQWM7QUFDL0MsK0RBQWUrRSxHQUFHQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvYXBpLnRzPzJmYWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEFQSSBDbGllbnQgZm9yIEJhY2tlbmQgSW50ZWdyYXRpb25cclxuICogQmFzZSBVUkw6IGh0dHA6Ly9sb2NhbGhvc3Q6ODAwMFxyXG4gKi9cclxuXHJcbmNvbnN0IEFQSV9CQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMCc7XHJcblxyXG5jbGFzcyBBcGlDbGllbnQge1xyXG4gIHByaXZhdGUgYmFzZVVSTDogc3RyaW5nO1xyXG5cclxuICBjb25zdHJ1Y3RvcihiYXNlVVJMOiBzdHJpbmcpIHtcclxuICAgIHRoaXMuYmFzZVVSTCA9IGJhc2VVUkw7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldEhlYWRlcnMoaW5jbHVkZUF1dGg6IGJvb2xlYW4gPSB0cnVlKTogSGVhZGVyc0luaXQge1xyXG4gICAgY29uc3QgaGVhZGVyczogSGVhZGVyc0luaXQgPSB7XHJcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChpbmNsdWRlQXV0aCAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpO1xyXG4gICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7dG9rZW59YDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBoZWFkZXJzO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVSZXNwb25zZTxUPihyZXNwb25zZTogUmVzcG9uc2UpOiBQcm9taXNlPFQ+IHtcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHsgZGV0YWlsOiAnQW4gZXJyb3Igb2NjdXJyZWQnIH0pKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLmRldGFpbCB8fCBgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c31gKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDQpIHtcclxuICAgICAgcmV0dXJuIHt9IGFzIFQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICB9XHJcblxyXG4gIC8vIEF1dGggQVBJc1xyXG4gIGFzeW5jIHNpZ251cChuYW1lOiBzdHJpbmcsIGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvYXV0aC9zaWdudXBgLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoZmFsc2UpLFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IG5hbWUsIGVtYWlsLCBwYXNzd29yZCB9KSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc2lnbmluKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvYXV0aC9zaWduaW5gLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoZmFsc2UpLFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVtYWlsLCBwYXNzd29yZCB9KSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgbG9nb3V0KCkge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVUkx9L2FwaS9hdXRoL2xvZ291dGAsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0SGVhZGVycygpLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRDdXJyZW50VXNlcigpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvYXV0aC9tZWAsIHtcclxuICAgICAgaGVhZGVyczogdGhpcy5nZXRIZWFkZXJzKCksXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcclxuICB9XHJcblxyXG4gIC8vIFRhc2sgQVBJc1xyXG4gIGFzeW5jIGdldFRhc2tzKHBhcmFtcz86IHtcclxuICAgIHN0YXR1cz86ICdhbGwnIHwgJ3BlbmRpbmcnIHwgJ2NvbXBsZXRlZCcgfCAnZGVsZXRlZCc7XHJcbiAgICBwcmlvcml0eT86ICdMT1cnIHwgJ01FRElVTScgfCAnSElHSCc7XHJcbiAgICBsaW1pdD86IG51bWJlcjtcclxuICAgIG9mZnNldD86IG51bWJlcjtcclxuICAgIGluY2x1ZGVfZGVsZXRlZD86IGJvb2xlYW47XHJcbiAgfSkge1xyXG4gICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XHJcbiAgICBpZiAocGFyYW1zPy5zdGF0dXMpIHF1ZXJ5UGFyYW1zLmFwcGVuZCgnc3RhdHVzJywgcGFyYW1zLnN0YXR1cyk7XHJcbiAgICBpZiAocGFyYW1zPy5wcmlvcml0eSkgcXVlcnlQYXJhbXMuYXBwZW5kKCdwcmlvcml0eScsIHBhcmFtcy5wcmlvcml0eSk7XHJcbiAgICBpZiAocGFyYW1zPy5saW1pdCkgcXVlcnlQYXJhbXMuYXBwZW5kKCdsaW1pdCcsIHBhcmFtcy5saW1pdC50b1N0cmluZygpKTtcclxuICAgIGlmIChwYXJhbXM/Lm9mZnNldCkgcXVlcnlQYXJhbXMuYXBwZW5kKCdvZmZzZXQnLCBwYXJhbXMub2Zmc2V0LnRvU3RyaW5nKCkpO1xyXG4gICAgaWYgKHBhcmFtcz8uaW5jbHVkZV9kZWxldGVkKSBxdWVyeVBhcmFtcy5hcHBlbmQoJ2luY2x1ZGVfZGVsZXRlZCcsICd0cnVlJyk7XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuICAgICAgYCR7dGhpcy5iYXNlVVJMfS9hcGkvdGFza3M/JHtxdWVyeVBhcmFtcy50b1N0cmluZygpfWAsXHJcbiAgICAgIHsgaGVhZGVyczogdGhpcy5nZXRIZWFkZXJzKCkgfVxyXG4gICAgKTtcclxuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFRhc2sodGFza0lkOiBudW1iZXIpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvdGFza3MvJHt0YXNrSWR9YCwge1xyXG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoKSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgY3JlYXRlVGFzayh0aXRsZTogc3RyaW5nLCBkZXNjcmlwdGlvbj86IHN0cmluZywgcHJpb3JpdHk6ICdMT1cnIHwgJ01FRElVTScgfCAnSElHSCcgPSAnTUVESVVNJywgZHVlX2RhdGU/OiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvdGFza3NgLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoKSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB0aXRsZSwgZGVzY3JpcHRpb24sIHByaW9yaXR5LCBkdWVfZGF0ZSB9KSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgdXBkYXRlVGFzayh0YXNrSWQ6IG51bWJlciwgZGF0YTogeyB0aXRsZT86IHN0cmluZzsgZGVzY3JpcHRpb24/OiBzdHJpbmc7IGNvbXBsZXRlZD86IGJvb2xlYW47IHByaW9yaXR5PzogJ0xPVycgfCAnTUVESVVNJyB8ICdISUdIJzsgZHVlX2RhdGU/OiBzdHJpbmcgfSkge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVUkx9L2FwaS90YXNrcy8ke3Rhc2tJZH1gLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BBVENIJyxcclxuICAgICAgaGVhZGVyczogdGhpcy5nZXRIZWFkZXJzKCksXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyB0b2dnbGVUYXNrQ29tcGxldGUodGFza0lkOiBudW1iZXIpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvdGFza3MvJHt0YXNrSWR9L2NvbXBsZXRlYCwge1xyXG4gICAgICBtZXRob2Q6ICdQQVRDSCcsXHJcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0SGVhZGVycygpLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBkZWxldGVUYXNrKHRhc2tJZDogbnVtYmVyKSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVSTH0vYXBpL3Rhc2tzLyR7dGFza0lkfWAsIHtcclxuICAgICAgbWV0aG9kOiAnREVMRVRFJyxcclxuICAgICAgaGVhZGVyczogdGhpcy5nZXRIZWFkZXJzKCksXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHJlc3RvcmVUYXNrKHRhc2tJZDogbnVtYmVyKSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVSTH0vYXBpL3Rhc2tzLyR7dGFza0lkfS9yZXN0b3JlYCwge1xyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgaGVhZGVyczogdGhpcy5nZXRIZWFkZXJzKCksXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcclxuICB9XHJcblxyXG4gIC8vIE5vdGlmaWNhdGlvbiBBUElzXHJcbiAgYXN5bmMgZ2V0Tm90aWZpY2F0aW9ucyhwYXJhbXM/OiB7XHJcbiAgICBsaW1pdD86IG51bWJlcjtcclxuICAgIG9mZnNldD86IG51bWJlcjtcclxuICAgIHVucmVhZF9vbmx5PzogYm9vbGVhbjtcclxuICAgIHNvcnQ/OiAnYXNjJyB8ICdkZXNjJztcclxuICB9KSB7XHJcbiAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcclxuICAgIGlmIChwYXJhbXM/LmxpbWl0KSBxdWVyeVBhcmFtcy5hcHBlbmQoJ2xpbWl0JywgcGFyYW1zLmxpbWl0LnRvU3RyaW5nKCkpO1xyXG4gICAgaWYgKHBhcmFtcz8ub2Zmc2V0KSBxdWVyeVBhcmFtcy5hcHBlbmQoJ29mZnNldCcsIHBhcmFtcy5vZmZzZXQudG9TdHJpbmcoKSk7XHJcbiAgICBpZiAocGFyYW1zPy51bnJlYWRfb25seSkgcXVlcnlQYXJhbXMuYXBwZW5kKCd1bnJlYWRfb25seScsICd0cnVlJyk7XHJcbiAgICBpZiAocGFyYW1zPy5zb3J0KSBxdWVyeVBhcmFtcy5hcHBlbmQoJ3NvcnQnLCBwYXJhbXMuc29ydCk7XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuICAgICAgYCR7dGhpcy5iYXNlVVJMfS9hcGkvbm90aWZpY2F0aW9ucz8ke3F1ZXJ5UGFyYW1zLnRvU3RyaW5nKCl9YCxcclxuICAgICAgeyBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoKSB9XHJcbiAgICApO1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgbWFya05vdGlmaWNhdGlvblJlYWQobm90aWZpY2F0aW9uSWQ6IG51bWJlcikge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVUkx9L2FwaS9ub3RpZmljYXRpb25zLyR7bm90aWZpY2F0aW9uSWR9YCwge1xyXG4gICAgICBtZXRob2Q6ICdQVVQnLFxyXG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoKSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBpc19yZWFkOiB0cnVlIH0pLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBtYXJrQWxsTm90aWZpY2F0aW9uc1JlYWQoKSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVSTH0vYXBpL25vdGlmaWNhdGlvbnMvbWFyay1hbGwtcmVhZGAsIHtcclxuICAgICAgbWV0aG9kOiAnUFVUJyxcclxuICAgICAgaGVhZGVyczogdGhpcy5nZXRIZWFkZXJzKCksXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGRlbGV0ZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb25JZDogbnVtYmVyKSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVSTH0vYXBpL25vdGlmaWNhdGlvbnMvJHtub3RpZmljYXRpb25JZH1gLCB7XHJcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXHJcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0SGVhZGVycygpLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRVbnJlYWRDb3VudCgpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvbm90aWZpY2F0aW9ucy91bnJlYWQvY291bnRgLCB7XHJcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0SGVhZGVycygpLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgfVxyXG5cclxuICAvLyBQcm9maWxlIEFQSXNcclxuICBhc3luYyBnZXRQcm9maWxlKCkge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVUkx9L2FwaS9wcm9maWxlYCwge1xyXG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoKSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgdXBkYXRlUHJvZmlsZShkYXRhOiB7XHJcbiAgICBuYW1lPzogc3RyaW5nO1xyXG4gICAgZmlyc3RfbmFtZT86IHN0cmluZztcclxuICAgIGxhc3RfbmFtZT86IHN0cmluZztcclxuICAgIHBob25lPzogc3RyaW5nO1xyXG4gICAgZGF0ZV9vZl9iaXJ0aD86IHN0cmluZztcclxuICAgIGdlbmRlcj86IHN0cmluZztcclxuICAgIGFkZHJlc3M/OiBzdHJpbmc7XHJcbiAgICBjaXR5Pzogc3RyaW5nO1xyXG4gICAgY291bnRyeT86IHN0cmluZztcclxuICAgIGJpbz86IHN0cmluZztcclxuICB9KSB7XHJcbiAgICAvLyBSZW1vdmUgZW1wdHkgc3RyaW5ncyBhbmQgY29udmVydCB0byBudWxsXHJcbiAgICBjb25zdCBjbGVhbmVkRGF0YSA9IE9iamVjdC5mcm9tRW50cmllcyhcclxuICAgICAgT2JqZWN0LmVudHJpZXMoZGF0YSkubWFwKChba2V5LCB2YWx1ZV0pID0+IFtcclxuICAgICAgICBrZXksXHJcbiAgICAgICAgdmFsdWUgPT09ICcnID8gbnVsbCA6IHZhbHVlXHJcbiAgICAgIF0pXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvcHJvZmlsZWAsIHtcclxuICAgICAgbWV0aG9kOiAnUFVUJyxcclxuICAgICAgaGVhZGVyczogdGhpcy5nZXRIZWFkZXJzKCksXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGNsZWFuZWREYXRhKSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgdXBsb2FkUHJvZmlsZVBob3RvKGZpbGU6IEZpbGUpIHtcclxuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XHJcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCBmaWxlKTtcclxuXHJcbiAgICBjb25zdCB0b2tlbiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3Rva2VuJykgOiBudWxsO1xyXG4gICAgY29uc3QgaGVhZGVyczogSGVhZGVyc0luaXQgPSB7fTtcclxuICAgIGlmICh0b2tlbikge1xyXG4gICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7dG9rZW59YDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVSTH0vYXBpL3Byb2ZpbGUvdXBsb2FkLXBob3RvYCwge1xyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgaGVhZGVycyxcclxuICAgICAgYm9keTogZm9ybURhdGEsXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGRlbGV0ZVByb2ZpbGVQaG90bygpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvcHJvZmlsZS9waG90b2AsIHtcclxuICAgICAgbWV0aG9kOiAnREVMRVRFJyxcclxuICAgICAgaGVhZGVyczogdGhpcy5nZXRIZWFkZXJzKCksXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcclxuICB9XHJcblxyXG4gIC8vIENvbnRhY3QgQVBJXHJcbiAgYXN5bmMgc3VibWl0Q29udGFjdEZvcm0oZGF0YToge1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgZW1haWw6IHN0cmluZztcclxuICAgIHN1YmplY3Q6IHN0cmluZztcclxuICAgIG1lc3NhZ2U6IHN0cmluZztcclxuICB9KSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVSTH0vYXBpL2NvbnRhY3RgLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoZmFsc2UpLFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGFwaSA9IG5ldyBBcGlDbGllbnQoQVBJX0JBU0VfVVJMKTtcclxuZXhwb3J0IGRlZmF1bHQgYXBpO1xyXG4iXSwibmFtZXMiOlsiQVBJX0JBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJBcGlDbGllbnQiLCJnZXRIZWFkZXJzIiwiaW5jbHVkZUF1dGgiLCJoZWFkZXJzIiwidG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiaGFuZGxlUmVzcG9uc2UiLCJyZXNwb25zZSIsIm9rIiwiZXJyb3IiLCJqc29uIiwiY2F0Y2giLCJkZXRhaWwiLCJFcnJvciIsInN0YXR1cyIsInNpZ251cCIsIm5hbWUiLCJlbWFpbCIsInBhc3N3b3JkIiwiZmV0Y2giLCJiYXNlVVJMIiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzaWduaW4iLCJsb2dvdXQiLCJnZXRDdXJyZW50VXNlciIsImdldFRhc2tzIiwicGFyYW1zIiwicXVlcnlQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJhcHBlbmQiLCJwcmlvcml0eSIsImxpbWl0IiwidG9TdHJpbmciLCJvZmZzZXQiLCJpbmNsdWRlX2RlbGV0ZWQiLCJnZXRUYXNrIiwidGFza0lkIiwiY3JlYXRlVGFzayIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJkdWVfZGF0ZSIsInVwZGF0ZVRhc2siLCJkYXRhIiwidG9nZ2xlVGFza0NvbXBsZXRlIiwiZGVsZXRlVGFzayIsInJlc3RvcmVUYXNrIiwiZ2V0Tm90aWZpY2F0aW9ucyIsInVucmVhZF9vbmx5Iiwic29ydCIsIm1hcmtOb3RpZmljYXRpb25SZWFkIiwibm90aWZpY2F0aW9uSWQiLCJpc19yZWFkIiwibWFya0FsbE5vdGlmaWNhdGlvbnNSZWFkIiwiZGVsZXRlTm90aWZpY2F0aW9uIiwiZ2V0VW5yZWFkQ291bnQiLCJnZXRQcm9maWxlIiwidXBkYXRlUHJvZmlsZSIsImNsZWFuZWREYXRhIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwibWFwIiwia2V5IiwidmFsdWUiLCJ1cGxvYWRQcm9maWxlUGhvdG8iLCJmaWxlIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImRlbGV0ZVByb2ZpbGVQaG90byIsInN1Ym1pdENvbnRhY3RGb3JtIiwiY29uc3RydWN0b3IiLCJhcGkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});